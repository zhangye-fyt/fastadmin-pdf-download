{"version":3,"sources":["hc-sticky.js","hc-sticky.helpers.js","init.js"],"names":["global","factory","module","exports","document","Error","define","amd","window","this","hcSticky","elem","userSettings","querySelector","queries","deprecated","queryFlow","let","STICKY_OPTIONS","Helpers","elemParent","parentNode","setOptions","getStyle","style","position","options","isEmptyObject","Object","assign","DEFAULT_OPTIONS","resetOptions","isDisabled","disable","applyQueries","mediaQueries","responsive","window_width","innerWidth","mobileFirst","width","queriesArr","b","q","push","i","length","query","breakpoint","keys","getStickyCss","cascadedStyle","getCascadedStyle","el","computedStyle","css","height","offsetHeight","left","right","top","bottom","display","verticalAlign","boxSizing","marginLeft","marginRight","marginTop","marginBottom","paddingLeft","paddingRight","cssFloat","MozBoxSizing","offsetWidth","Sticky","stick","args","hasClass","stickyClass","Spacer","isAttached","attach","offsetLeft","classList","add","className","onStart","call","release","stop","parseInt","detach","positionLeft","remove","replace","RegExp","split","join","onStop","createElement","init","prop","elemStyle","offset","insertBefore","removeChild","stickTo_document","container","inner_sticker","container_height","container_offsetTop","elemParent_offsetTop","window_height","options_top","options_bottom","stick_top","stick_bottom","top_limit","bottom_limit","largerSticky","sticky_height","sticky_offsetTop","calcContainerHeight","calcStickyHeight","calcSticky","stickTo","nodeType","HTMLDocument","Document","getElement","h_diff","Math","max","documentElement","clientHeight","body","scrollHeight","innerHeight","offsetTop","innerSticker","isNaN","indexOf","parseFloat","innerTop","bottomEnd","last_pos","pageYOffset","scrollTop","diff_y","scroll_dir","runSticky","bottom_distance","offset_top","sticky_top","sticky_window_top","followScroll","ceil","scrollAttached","resizeAttached","disableSticky","removeEventListener","supportsPassive","initSticky","offsetParent","addEventListener","resetSticky","reinitSticky","resizeSticky","onBeforeResize","onResize","resize_cb","resizeDebounce","debounce","Detach","Attach","option","refresh","update","destroy","triggerMethod","method","reinit","what","instead","type","console","warn","jQuery","$","namespace","fn","extend","data","get","each","instance","defineProperty","value","target","varArgs","TypeError","to","index","arguments","nextSource","nextKey","prototype","hasOwnProperty","writable","configurable","Array","forEach","callback","T","k","kValue","O","len","opts","passive","e","getComputedStyle","defaultView","getPropertyValue","currentStyle","s","toUpperCase","rect","getBoundingClientRect","scrollLeft","pageXOffset","name","obj","func","wait","immediate","timeout","context","callNow","clearTimeout","setTimeout","apply","contains","test","parentOffset","elemOffset","prentStyle","borderTopWidth","borderLeftWidth","node","Element","clone","cloneNode","slice","querySelectorAll","removeAttribute","nextSibling","posLeft","margin","diff","$body","updateStickySize","group","$stickyColumns","getStickyColumns","find","getStickyOffset","trigger","$columns","$highestColumn","highestHeight","thisArea","outerHeight","not","$pageHeader","addClass","removeClass","on","$parent","1007"],"mappings":"AAWA,aAEA,CAAA,SAAAA,EAAAC,GACA,GAAA,UAAA,OAAAC,QAAA,UAAA,OAAAA,OAAAC,QAAA,CACA,GAAAH,CAAAA,EAAAI,SAIA,MAAA,IAAAC,MAAA,sCAAA,EAHAH,OAAAC,QAAAF,EAAAD,CAAA,CAKA,KACA,YAAA,OAAAM,QAAAA,OAAAC,IACAD,OAAA,WAAA,GAAAL,EAAAD,CAAA,CAAA,EAGAC,EAAAD,CAAA,CAEA,EAAA,aAAA,OAAAQ,OAAAA,OAAAC,KAAA,IA0CA,SAAAC,EAAAC,EAAAC,GASA,GARAA,EAAAA,GAAA,GAQA,EAJAD,EADA,UAAA,OAAAA,EACAP,EAAAS,cAAAF,CAAA,EAIAA,GAAA,MAAA,CAAA,EAEAC,EAAAE,SACAC,EAAA,UAAA,aAAA,QAAA,EAGAH,EAAAI,WACAD,EAAA,YAAA,cAAA,QAAA,EAGAE,IAAAC,EAAA,GACA,MAAAC,EAAAT,EAAAS,QACAC,EAAAT,EAAAU,WAOAC,GAJA,WAAAH,EAAAI,SAAAH,EAAA,UAAA,IACAA,EAAAI,MAAAC,SAAA,YAGA,IACAC,EAAAA,GAAA,GAEAP,EAAAQ,cAAAD,CAAA,GAAA,CAAAP,EAAAQ,cAAAT,CAAA,IAMAA,EAAAU,OAAAC,OAAA,GAAAC,EAAAZ,EAAAQ,CAAA,EACA,GAEAK,EAAA,IACAb,EAAAU,OAAAC,OAAA,GAAAC,EAAAJ,GAAA,EAAA,CACA,EAMAM,EAAA,IACAd,EAAAe,QAGAC,EAAA,KACA,IAAAC,EAAAjB,EAAAkB,YAAAlB,EAAAJ,QAEA,GAAAqB,EAAA,CACA,IAAAE,EAAA7B,EAAA8B,WAKA,GAFAP,EAAAnB,CAAA,EAEAM,EAAAqB,YACA,IAAA,MAAAC,KAAAL,EACAE,GAAAG,GAAA,CAAArB,EAAAQ,cAAAQ,EAAAK,EAAA,GACAlB,EAAAa,EAAAK,EAAA,MAIA,CACA,IAAAC,EAAA,GAGA,IAAA,MAAAC,KAAAP,EAAA,CACA,IAAAQ,EAAA,GAEAA,EAAAD,GAAAP,EAAAO,GACAD,EAAAG,KAAAD,CAAA,CACA,CAEA,IAAA1B,IAAA4B,EAAAJ,EAAAK,OAAA,EAAA,GAAAD,EAAAA,CAAA,GAAA,CACA,IAAAE,EAAAN,EAAAI,GACAG,EAAApB,OAAAqB,KAAAF,CAAA,EAAA,GAEAV,GAAAW,GAAA,CAAA7B,EAAAQ,cAAAoB,EAAAC,EAAA,GACA1B,EAAAyB,EAAAC,EAAA,CAEA,CACA,CACA,CACA,EAGAE,EAAA,IACA,IAAAC,EAAAhC,EAAAiC,iBAAAC,CAAA,EACAC,EAAAnC,EAAAI,SAAA8B,CAAA,EAEAE,EAAA,CACAC,OAAAH,EAAAI,aAAA,KACAC,KAAAP,EAAAO,KACAC,MAAAR,EAAAQ,MACAC,IAAAT,EAAAS,IACAC,OAAAV,EAAAU,OACApC,SAAA6B,EAAA7B,SACAqC,QAAAR,EAAAQ,QACAC,cAAAT,EAAAS,cACAC,UAAAV,EAAAU,UACAC,WAAAd,EAAAc,WACAC,YAAAf,EAAAe,YACAC,UAAAhB,EAAAgB,UACAC,aAAAjB,EAAAiB,aACAC,YAAAlB,EAAAkB,YACAC,aAAAnB,EAAAmB,YACA,EAiBA,OAfAnB,EAAA,QACAI,EAAA,MAAAJ,EAAA,OAAA,QAGAA,EAAAoB,WACAhB,EAAA,SAAAJ,EAAAoB,UAAA,QAIAjB,EAAAkB,eACAjB,EAAA,aAAAD,EAAAkB,cAGAjB,EAAA,MAAA,SAAAJ,EAAAX,MAAAW,EAAAX,MAAA,eAAAe,EAAAS,WAAA,eAAAT,EAAAiB,aAAAnB,EAAAoB,YAAA,KAAAnB,EAAAd,MAEAe,CACA,EAEAmB,EAAA,CACAnB,IAAA,GACA9B,SAAA,KACAkD,MAAA,IACAC,EAAAA,GAAA,GAGAzD,EAAA0D,SAAAlE,EAAAO,EAAA4D,WAAA,IAIA,CAAA,IAAAC,EAAAC,YACAD,EAAAE,OAAA,EAGAP,EAAAjD,SAAA,QAGAd,EAAAa,MAAAC,SAAA,QACAd,EAAAa,MAAAkC,KAAAqB,EAAAG,WAAA,KACAvE,EAAAa,MAAAgB,MAAAuC,EAAAvC,MAEA,KAAA,IAAAoC,EAAAf,OACAlD,EAAAa,MAAAqC,OAAA,OAGAlD,EAAAa,MAAAqC,OAAAe,EAAAf,OAAA,KAGA,KAAA,IAAAe,EAAAhB,IACAjD,EAAAa,MAAAoC,IAAA,OAGAjD,EAAAa,MAAAoC,IAAAgB,EAAAhB,IAAA,KAIAjD,EAAAwE,UACAxE,EAAAwE,UAAAC,IAAAlE,EAAA4D,WAAA,EAGAnE,EAAA0E,WAAA,IAAAnE,EAAA4D,YAIA5D,EAAAoE,SACApE,EAAAoE,QAAAC,KAAA5E,EAAAiB,OAAAC,OAAA,GAAAX,CAAA,CAAA,EAEA,EACAsE,QAAA,IAKA,IAqBA/D,GAzBAmD,EAAAA,GAAA,IACAa,KAAAb,EAAAa,MAAA,CAAA,EAGA,CAAA,IAAAb,EAAAa,MAAA,UAAAf,EAAAjD,UAAA,OAAAiD,EAAAjD,WACA,KAAA,IAAAmD,EAAAhB,KAAA,KAAA,IAAAgB,EAAAf,QACA,KAAA,IAAAe,EAAAhB,MAAA8B,SAAAvE,EAAAI,SAAAZ,EAAA,KAAA,CAAA,GAAA,KAAAiE,EAAAhB,KACA,KAAA,IAAAgB,EAAAf,SAAA6B,SAAAvE,EAAAI,SAAAZ,EAAA,QAAA,CAAA,GAAA,KAAAiE,EAAAf,UAKA,CAAA,IAAAe,EAAAa,KAEA,CAAA,IAAAV,EAAAC,YACAD,EAAAY,OAAA,EAKA,CAAA,IAAAZ,EAAAC,YACAD,EAAAE,OAAA,EAIAxD,EAAAmD,EAAAnD,UAAAiD,EAAAnB,IAAA9B,SAGAiD,EAAAjD,SAAAA,EAGAd,EAAAa,MAAAC,SAAAA,EACAd,EAAAa,MAAAkC,KAAA,CAAA,IAAAkB,EAAAa,KAAAf,EAAAnB,IAAAG,KAAAqB,EAAAa,aAAA,KACAjF,EAAAa,MAAAgB,OAAA,aAAAf,EAAAiD,EAAAnB,IAAAwB,GAAAvC,MAEA,KAAA,IAAAoC,EAAAf,OACAlD,EAAAa,MAAAqC,OAAA,CAAA,IAAAe,EAAAa,KAAA,GAAA,OAGA9E,EAAAa,MAAAqC,OAAAe,EAAAf,OAAA,KAGA,KAAA,IAAAe,EAAAhB,IACAjD,EAAAa,MAAAoC,IAAA,CAAA,IAAAgB,EAAAa,KAAA,GAAA,OAGA9E,EAAAa,MAAAoC,IAAAgB,EAAAhB,IAAA,KAIAjD,EAAAwE,UACAxE,EAAAwE,UAAAU,OAAA3E,EAAA4D,WAAA,EAGAnE,EAAA0E,UAAA1E,EAAA0E,UAAAS,QAAA,IAAAC,OAAA,UAAA7E,EAAA4D,YAAAkB,MAAA,GAAA,EAAAC,KAAA,GAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAIA/E,EAAAgF,QACAhF,EAAAgF,OAAAX,KAAA5E,EAAAiB,OAAAC,OAAA,GAAAX,CAAA,CAAA,EAEA,CACA,EAEA6D,EAAA,CACA1B,GAAAjD,EAAA+F,cAAA,KAAA,EACAjB,WAAA,KACAU,aAAA,KACApD,MAAA,KACAwC,WAAA,CAAA,EACAoB,KAAA,KACArB,EAAA1B,GAAAgC,UAAA,gBAGA,IAAA,MAAAgB,KAAA3B,EAAAnB,IACAwB,EAAA1B,GAAA7B,MAAA6E,GAAA3B,EAAAnB,IAAA8C,GAIAtB,EAAA1B,GAAA7B,MAAA,WAAA,KAEA,IAAA8E,EAAAnF,EAAAI,SAAAZ,CAAA,EAGAoE,EAAAG,WAAA/D,EAAAoF,OAAA5F,CAAA,EAAA+C,MAAAgC,SAAAY,EAAArC,UAAA,GAAA,GACAc,EAAAa,aAAAzE,EAAAM,SAAAd,CAAA,EAAA+C,KAGAqB,EAAAvC,MAAArB,EAAAI,SAAAZ,EAAA,OAAA,CACA,EACAsE,OAAA,KAEA7D,EAAAoF,aAAAzB,EAAA1B,GAAA1C,CAAA,EACAoE,EAAAC,WAAA,CAAA,CACA,EACAW,OAAA,KAEAZ,EAAA1B,GAAAjC,EAAAqF,YAAA1B,EAAA1B,EAAA,EACA0B,EAAAC,WAAA,CAAA,CACA,CACA,EAGA/D,IAAAyF,EACAC,EACAC,EAEAC,EACAC,EAEAC,EAEAC,EAEAC,EACAC,EAEAC,EACAC,EAEAC,EACAC,EAEAC,EACAC,EACAC,EAEAC,EACAC,EAEA,MAAAC,EAAA,KAEAlD,EAAAnB,IAAAL,EAAAvC,CAAA,EAGAoE,EAAAqB,KAAA,EAGAM,EAAAxF,EAAAA,CAAAA,EAAA2G,SAAA,EAAA,aAAA3G,EAAA2G,SACA3G,EAAA2G,QAAAC,UAAA,IAAA5G,EAAA2G,QAAAC,UACA,UAAA,OAAA5G,EAAA2G,SAAA3G,EAAA2G,mBAAA,aAAA,OAAAE,aAAAA,aAAAC,YAIArB,EAAAzF,EAAA2G,QACAnB,EACAtG,EACAe,EAAA8G,WAAA/G,EAAA2G,OAAA,EACAzG,EAGAuG,EAAA,KACA,IAAAnE,EAAA7C,EAAA8C,cAAAiC,SAAAhB,EAAAnB,IAAAY,SAAA,GAAA,IAAAuB,SAAAhB,EAAAnB,IAAAa,YAAA,GAAA,GACA8D,GAAAV,GAAA,GAAAhE,EAEA,MAAA,CAAA,GAAA0E,GAAAA,GAAA,EAEAV,EAGAhE,CAEA,EAEAgE,EAAAG,EAAA,EAGAD,EAAA,IACAhB,EAAAyB,KAAAC,IAAAhI,EAAAiI,gBAAAC,aAAAlI,EAAAmI,KAAAC,aAAApI,EAAAiI,gBAAAG,aAAApI,EAAAmI,KAAA9E,aAAArD,EAAAiI,gBAAA5E,YAAA,EAAAkD,EAAAlD,aAGAoD,EAAAa,EAAA,EAEAZ,EAAAJ,EAAA,EAAAvF,EAAAoF,OAAAI,CAAA,EAAA/C,IACAmD,EAAA7F,EAAA2G,QAEAnB,EAEA,EADAvF,EAAAoF,OAAAnF,CAAA,EAAAwC,IAFAkD,EAIAE,EAAAxG,EAAAiI,YACAhB,EAAA9G,EAAA+H,WAAAhD,SAAAhB,EAAAnB,IAAAY,SAAA,GAAA,GAGAyC,EAAAzF,EAAA8G,WAAA/G,EAAAyH,YAAA,EAGA1B,EAAA2B,MAAA1H,EAAA0C,GAAA,GAAA,CAAA,EAAA1C,EAAA0C,IAAAiF,QAAA,GAAA,EACAC,WAAA5H,EAAA0C,GAAA,EAAA,IAAAoD,EACA9F,EAAA0C,IAGAsD,EAAA0B,MAAA1H,EAAA2C,MAAA,GAAA,CAAA,EAAA3C,EAAA2C,OAAAgF,QAAA,GAAA,EACAC,WAAA5H,EAAA2C,MAAA,EAAA,IAAAmD,EACA9F,EAAA2C,OAGAsD,EAAAP,EACAA,EAAA8B,UACAxH,EAAA6H,UAEA,EAEA3B,EAAAwB,MAAA1H,EAAA8H,SAAA,GAAA,CAAA,EAAA9H,EAAA8H,UAAAH,QAAA,GAAA,EACAC,WAAA5H,EAAA8H,SAAA,EAAA,IAAAhC,EACA9F,EAAA8H,UAEA3B,EAAAP,EAAAG,EAAAE,EAAAM,CACA,EAGAxG,IAAAgI,EAAAzI,EAAA0I,aAAA9I,EAAAiI,gBAAAc,UACAC,EAAA,EACAC,EAEA,MAAAC,EAAA,KAEA9B,EAAAG,EAAA,EACAd,EAAAa,EAAA,EAEAJ,EAAAR,EAAAD,EAAAI,EAAAG,EAGAG,EAAAC,EAAAR,EAEA,IAGAuC,EAHAC,EAAAhJ,EAAA0I,aAAA9I,EAAAiI,gBAAAc,UACAM,EAAAtI,EAAAoF,OAAA5F,CAAA,EAAAiD,IACA8F,EAAAD,EAAAD,EAIAH,EAAAG,EAAAP,EAAA,KAAA,OACAG,EAAAI,EAAAP,GACAA,EAAAO,GAEAnC,EAEAC,EAAAL,GAAAM,EAAAL,EAAA,IAAAhG,EAAAyI,cAAApC,EAAA,EAAAN,IAAAuC,EAAAhC,EAAAL,GAAAK,EAAAL,EAAAH,GAAAK,EAAAF,IAAAjG,EAAAyI,cAAA,GAAAJ,EAAA/B,EAAAR,EAAAG,GAAAoC,EAAA,GACA7E,EAAAc,QAAA,CACA/D,SAAA,WAEAoC,OAAAkD,EAAA3F,EAAAqC,aAAA6D,EAAAL,CACA,CAAA,EAEAM,GAAArG,EAAAyI,aACA,SAAAN,EACAK,EAAAlC,EAAAN,GAAAF,EAAA,GAEAtC,EAAAC,MAAA,CAEAd,OAAAqD,CACA,CAAA,EAEA,UAAAxC,EAAAjD,UACAiD,EAAAc,QAAA,CACA/D,SAAA,WACAmC,IAAA6F,EAAAxC,EAAAI,EAAA+B,EAAAjC,CACA,CAAA,EAIAgB,KAAAyB,KAAAF,EAAAvC,CAAA,EAAA,GAAA,UAAAzC,EAAAjD,SACAiD,EAAAc,QAAA,CACA/D,SAAA,WACAmC,IAAA6F,EAAAxC,EAAAI,EAAAF,EAAAiC,CACA,CAAA,EAEAK,GAAAD,EAAAvC,EAAAE,GACAzC,EAAAC,MAAA,CACAf,IAAAqD,EAAAE,CACA,CAAA,EAKAzC,EAAAC,MAAA,CACAf,IAAAqD,EAAAE,CACA,CAAA,EAIAzC,EAAAc,QAAA,CACAC,KAAA,CAAA,CACA,CAAA,CAEA,EAEAxE,IAAA4I,EAAA,CAAA,EACAC,EAAA,CAAA,EAEA,MAAAC,EAAA,KACAF,IAEArJ,EAAAwJ,oBAAA,SAAAV,EAAAnI,EAAA8I,eAAA,EAGAJ,EAAA,CAAA,EAEA,EAEAK,EAAA,KAEA,OAAAvJ,EAAAwJ,cAAA,SAAAhJ,EAAAI,SAAAZ,EAAA,SAAA,IAMAiH,EAAA,EAGAJ,EAAAX,GACAkD,EAAA,GAKAT,EAAA,EAEAO,IAEArJ,EAAA4J,iBAAA,SAAAd,EAAAnI,EAAA8I,eAAA,EAGAJ,EAAA,CAAA,GAEA,EAEAQ,EAAA,KAEA1J,EAAAa,MAAAC,SAAA,GACAd,EAAAa,MAAAkC,KAAA,GACA/C,EAAAa,MAAAoC,IAAA,GACAjD,EAAAa,MAAAqC,OAAA,GACAlD,EAAAa,MAAAgB,MAAA,GAGA7B,EAAAwE,UACAxE,EAAAwE,UAAAU,OAAA3E,EAAA4D,WAAA,EAGAnE,EAAA0E,UAAA1E,EAAA0E,UAAAS,QAAA,IAAAC,OAAA,UAAA7E,EAAA4D,YAAAkB,MAAA,GAAA,EAAAC,KAAA,GAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAIAvB,EAAAnB,IAAA,GAIA,EAHAmB,EAAAjD,SAAA,QAGAsD,EAAAC,YACAD,EAAAY,OAAA,CAEA,EAEA2E,EAAA,KACAD,EAAA,EACAnI,EAAA,GAEAF,EAAA,EACA+H,EAKAG,GALA,CAMA,EAEA,IAAAK,EAAA,KAEArJ,EAAAsJ,gBACAtJ,EAAAsJ,eAAAjF,KAAA5E,EAAAiB,OAAAC,OAAA,GAAAX,CAAA,CAAA,EAIAoJ,EAAA,EAGApJ,EAAAuJ,UACAvJ,EAAAuJ,SAAAlF,KAAA5E,EAAAiB,OAAAC,OAAA,GAAAX,CAAA,CAAA,CAEA,EAEA,MAAAwJ,EAAAxJ,EAAAyJ,eAAAxJ,EAAAyJ,SAAAL,EAAArJ,EAAAyJ,cAAA,EAAAJ,EAYAM,EAAA,KAEAf,IACAtJ,EAAAwJ,oBAAA,SAAAU,EAAAvJ,EAAA8I,eAAA,EACAH,EAAA,CAAA,GAGAC,EAAA,CACA,EAOAe,EAAA,KAEAhB,IACAtJ,EAAA4J,iBAAA,SAAAM,EAAAvJ,EAAA8I,eAAA,EACAH,EAAA,CAAA,GAGA5H,EAAA,GAEAF,EAAA,EACA+H,EAIAG,GAJA,CAKA,EAEAzJ,KAAAiB,QAnjBA,GACAqJ,EAAA7J,EAAA6J,GAAAnJ,OAAAC,OAAA,GAAAX,CAAA,EAmjBAT,KAAAuK,QAAAV,EACA7J,KAAAwK,OA3CA,IACA3J,EAAAI,CAAA,EAGAd,EAAAgB,OAAAC,OAAA,GAAAjB,EAAAc,GAAA,EAAA,EAEA4I,EAAA,CACA,EAqCA7J,KAAAwE,OAAA6F,EACArK,KAAAkF,OAAAkF,EACApK,KAAAyK,QA3BA,KACAL,EAAA,EACAR,EAAA,CACA,EA2BA5J,KAAA0K,cAAA,CAAAC,EAAA1J,KACA,YAAA,OAAAjB,KAAA2K,IACA3K,KAAA2K,GAAA1J,CAAA,CAEA,EAEAjB,KAAA4K,OAAA,KACAtK,EAAA,SAAA,UAAA,QAAA,EACAuJ,EAAA,CACA,EAGAhJ,EAAAV,CAAA,EAGAkK,EAAA,EAGAtK,EAAA4J,iBAAA,OAAAE,CAAA,CACA,CAnqBA,MAAAlK,EAAAI,EAAAJ,SAEA0B,EAAA,CACA8B,IAAA,EACAC,OAAA,EACAmF,UAAA,EACAD,SAAA,EACAJ,aAAA,KACA7D,YAAA,SACA+C,QAAA,KACA8B,aAAA,CAAA,EACAvH,WAAA,KACAG,YAAA,CAAA,EACA+C,QAAA,KACAY,OAAA,KACAsE,eAAA,KACAC,SAAA,KACAE,eAAA,IACA1I,QAAA,CAAA,CACA,EAEAlB,EAGA,CAAAuK,EAAAC,EAAAC,KACAC,QAAAC,KACA,kBACAF,EACA,OAAAF,EAEA,qDAAAC,EACA,eACA,iBACA,iBACA,iBACA,iBACA,iBACA,gBAAA,CACA,EAgoBA,GAAA,KAAA,IAAA/K,EAAAmL,OAAA,CACA,MAAAC,EAAApL,EAAAmL,OACAE,EAAA,WAEAD,EAAAE,GAAAC,OAAA,CACArL,SAAA,SAAAkE,EAAAqG,GAEA,OAAAxK,KAAAqC,OAGA,YAAA8B,EACAgH,EAAAI,KAAAvL,KAAAwL,IAAA,CAAA,EAAAJ,CAAA,EAAAnK,QAAA,EAGAjB,KAAAyL,KAAA,WACAjL,IAAAkL,EAAAP,EAAAI,KAAAvL,KAAAoL,CAAA,EAEAM,EAEAA,EAAAhB,cAAAvG,EAAAqG,CAAA,GAIAkB,EAAA,IAAAzL,EAAAD,KAAAmE,CAAA,EACAgH,EAAAI,KAAAvL,KAAAoL,EAAAM,CAAA,EAEA,CAAA,EAnBA1L,IAoBA,CACA,CAAA,CACA,CAKA,OAFAD,EAAAE,SAAAF,EAAAE,UAAAA,EAEAA,CACA,CAAA,GCtuBA,IAGA,IAAAA,EAAAF,EAAAE,SACA,MAAAN,EAAAI,EAAAJ,SAKA,YAAA,OAAAwB,OAAAC,QACAD,OAAAwK,eAAAxK,OAAA,SAAA,CACAyK,MAAA,SAAAC,EAAAC,GAEA,GAAA,MAAAD,EACA,MAAA,IAAAE,UAAA,4CAAA,EAKA,IAFA,IAAAC,EAAA7K,OAAA0K,CAAA,EAEAI,EAAA,EAAAA,EAAAC,UAAA7J,OAAA4J,CAAA,GAAA,CACA,IAAAE,EAAAD,UAAAD,GAEA,GAAA,MAAAE,EACA,IAAA,IAAAC,KAAAD,EACAhL,OAAAkL,UAAAC,eAAAxH,KAAAqH,EAAAC,CAAA,IACAJ,EAAAI,GAAAD,EAAAC,GAIA,CACA,OAAAJ,CACA,EACAO,SAAA,CAAA,EACAC,aAAA,CAAA,CACA,CAAA,EAMAC,MAAAJ,UAAAK,UACAD,MAAAJ,UAAAK,QAAA,SAAAC,GACA,IAAAC,EAAAC,EAEA,GAAA,MAAA7M,KACA,MAAA,IAAA+L,UAAA,6BAAA,EAGA,IAcAe,EAdAC,EAAA5L,OAAAnB,IAAA,EACAgN,EAAAD,EAAA1K,SAAA,EAEA,GAAA,YAAA,OAAAsK,EACA,MAAA,IAAAZ,UAAAY,EAAA,oBAAA,EASA,IANA,EAAAT,UAAA7J,SACAuK,EAAAV,UAAA,IAGAW,EAAA,EAEAA,EAAAG,GAGAH,KAAAE,IACAD,EAAAC,EAAAF,GACAF,EAAA7H,KAAA8H,EAAAE,EAAAD,EAAAE,CAAA,GAGAF,CAAA,EAEA,GAGArM,IAAAgJ,EAAA,CAAA,EACA,IACA,IAAAyD,EAAA9L,OAAAwK,eAAA,GAAA,UAAA,CACAH,IAAA,WACAhC,EAAA,CAAA0D,QAAA,CAAA,CAAA,CACA,CACA,CAAA,EACAnN,EAAA4J,iBAAA,cAAA,KAAAsD,CAAA,EACAlN,EAAAwJ,oBAAA,cAAA,KAAA0D,CAAA,CACA,CAAA,MAAAE,IA2CA,MAAArM,EAAA,CAAA8B,EAAA7B,IACAhB,EAAAqN,iBACArM,EAAApB,EAAA0N,YAAAD,iBAAAxK,EAAA,IAAA,EAAA0K,iBAAAvM,CAAA,EAAApB,EAAA0N,YAAAD,iBAAAxK,EAAA,IAAA,EAEAA,EAAA2K,aACAxM,EAAA6B,EAAA2K,aAAAxM,EAAAsE,QAAA,OAAA,GACAmI,EAAAC,YAAA,EAAApI,QAAA,IAAA,EAAA,CACA,GAAAzC,EAAA2K,aAHA,KAAA,EA2BA,MAAAzH,EAAA,IACA,IAAA4H,EAAA9K,EAAA+K,sBAAA,EACAjF,EAAA3I,EAAA0I,aAAA9I,EAAAiI,gBAAAc,UACAkF,EAAA7N,EAAA8N,aAAAlO,EAAAiI,gBAAAgG,WAEA,MAAA,CACAzK,IAAAuK,EAAAvK,IAAAuF,EACAzF,KAAAyK,EAAAzK,KAAA2K,CACA,CACA,EA4FA3N,EAAAS,QAAA,CACA8I,gBAAAA,EACAtI,cA1HA,IACA,IAAA,MAAA4M,KAAAC,EACA,MAAA,CAAA,EAGA,MAAA,CAAA,CACA,EAqHA5D,SA/JA,CAAA6D,EAAAC,EAAAC,KACA1N,IAAA2N,EAEA,OAAA,WACA,MAAAC,EAAApO,KACAmE,EAAA+H,UACA,IAMAmC,EAAAH,GAAA,CAAAC,EAEAG,aAAAH,CAAA,EACAA,EAAAI,WATA,WACAJ,EAAA,KACAD,GACAF,EAAAQ,MAAAJ,EAAAjK,CAAA,CAEA,EAIA8J,CAAA,EAEAI,GACAL,EAAAQ,MAAAJ,EAAAjK,CAAA,CAEA,CACA,EA2IAC,SAnHA,CAAAxB,EAAAgC,IACAhC,EAAA8B,UACA9B,EAAA8B,UAAA+J,SAAA7J,CAAA,EAGA,IAAAU,OAAA,QAAAV,EAAA,QAAA,IAAA,EAAA8J,KAAA9L,EAAAgC,SAAA,EA+GAkB,OAAAA,EACA9E,SA/FA,IACA,IAAA0I,EAAA9G,EAAA8G,aACAiF,EAAA7I,EAAA4D,CAAA,EACAkF,EAAA9I,EAAAlD,CAAA,EACAiM,EAAA/N,EAAA4I,CAAA,EACA7D,EAAA/E,EAAA8B,CAAA,EAKA,OAHA+L,EAAAxL,KAAA8B,SAAA4J,EAAAC,cAAA,GAAA,EACAH,EAAA1L,MAAAgC,SAAA4J,EAAAE,eAAA,GAAA,EAEA,CACA5L,IAAAyL,EAAAzL,IAAAwL,EAAAxL,KAAA8B,SAAAY,EAAAnC,SAAA,GAAA,GACAT,KAAA2L,EAAA3L,KAAA0L,EAAA1L,MAAAgC,SAAAY,EAAArC,UAAA,GAAA,EACA,CACA,EAkFAgE,WApLA,IACAhH,IAAAwO,EAAA,KAYA,MAVA,UAAA,OAAApM,EACAoM,EAAArP,EAAAS,cAAAwC,CAAA,EAEA7C,EAAAmL,QAAAtI,aAAA7C,EAAAmL,QAAAtI,EAAAP,OACA2M,EAAApM,EAAA,GAEAA,aAAAqM,UACAD,EAAApM,GAGAoM,CACA,EAuKAlO,SAAAA,EACA6B,iBAjFA,IAEAnC,IAAA0O,EAAAtM,EAAAuM,UAAA,CAAA,CAAA,EAEAD,EAAAnO,MAAAsC,QAAA,OAGAoJ,MAAAJ,UAAA+C,MAAAtK,KAAAoK,EAAAG,iBAAA,qBAAA,CAAA,EAAA3C,QAAA,IACA9J,EAAA0M,gBAAA,MAAA,CACA,CAAA,EAGA1M,EAAAhC,WAAAmF,aAAAmJ,EAAAtM,EAAA2M,WAAA,EAGA/O,IAAA+M,EAUAxM,GARAmO,EAAA3B,aACAA,EAAA2B,EAAA3B,aAEAxN,EAAAqN,mBACAG,EAAA5N,EAAA0N,YAAAD,iBAAA8B,EAAA,IAAA,GAIA,IAEA,IAAA,MAAAtJ,KAAA2H,EACApF,CAAAA,MAAAvC,CAAA,GAAA,UAAA,OAAA2H,EAAA3H,IAAA,UAAA,OAAA2H,EAAA3H,KACA7E,EAAA6E,GAAA2H,EAAA3H,IAKA,GAAAzE,OAAAqB,KAAAzB,CAAA,EAAAsB,OAAA,EAAA,CACAtB,EAAA,GACA,IAAA,MAAA6E,KAAA2H,EACApF,MAAAvC,CAAA,IACA7E,EAAAwM,EAAA3H,GAAAP,QAAA,OAAA,GACAmI,EAAAC,YAAA,EAAApI,QAAA,IAAA,EAAA,CACA,GAAAkI,EAAAD,iBAAAC,EAAA3H,EAAA,EAGA,CAWA,IACA4J,EACAhM,EAaA,OAvBAzC,EAAA0O,QAAA,SAAA1O,EAAAyC,WAGAzC,EAAA0O,QAAA1O,EAAAyC,aAAAzC,EAAA0C,aAAA1C,EAAAyC,aAAAzC,EAAA2C,WAAA3C,EAAAyC,aAAAzC,EAAA4C,eACA5C,EAAA0O,OAAA1O,EAAAyC,YAHAzC,EAAA0O,OAAA,OAOA1O,EAAA0O,QAAA,QAAA1O,EAAAyC,YAAA,QAAAzC,EAAA0C,cAEAD,GADAgM,EAAA5M,EAAA6B,WAAA7B,EAAAhC,WAAA6D,aACAQ,SAAAlE,EAAAkC,IAAA,GAAA,IAAAgC,SAAAlE,EAAAmC,KAAA,GAAA,GAIA,IAFAwM,EADA9M,EAAAhC,WAAAoD,YAAApB,EAAAoB,YAAAwL,GAAAvK,SAAAlE,EAAAmC,KAAA,GAAA,IAAA+B,SAAAlE,EAAAkC,IAAA,GAAA,GACAO,IAEA,GAAAkM,KACA3O,EAAA0O,OAAA,QAKAP,EAAAtO,WAAAoF,YAAAkJ,CAAA,EACAA,EAAA,KAEAnO,CACA,CAYA,CAEA,GAAAhB,MAAA,EC7QA,SAAAoL,GAGA,IAAAwE,EAAAxE,EAAA,MAAA,EAiDA,SAAAyE,IACAzE,EAAA,mBAAA,EAAAM,KAAA,WACA,IACAoE,EADA1E,EAAAnL,IAAA,EACAuL,KAAA,cAAA,EAEAuE,EAAAC,EADA5E,EAAAnL,IAAA,EAAAgQ,KAAA,wCAAAH,EAAA,IAAA,CACA,EACAI,EAAA,EAEAH,EAAA7P,SAAA,SAAA,EAEAkL,EAAApL,MAAA,EAAAmQ,QAAA,QAAA,CACA,CAAA,CACA,CAEA,SAAAH,EAAAI,GACA,IAAAC,EACAC,EAAA,EAUA,OARAF,EAAA1E,KAAA,WACA,IAAA6E,EAAAnF,EAAAnL,IAAA,EAAAuQ,YAAA,EACAF,EAAAC,IACAF,EAAAjF,EAAAnL,IAAA,EACAqQ,EAAAC,EAEA,CAAA,EAEAH,EAAAK,IAAAJ,CAAA,CACA,CAEA,SAAAH,IACA,IAAAQ,EAAAtF,EAAA,cAAA,EACArF,EAAA,EA4BA,OA1BA6J,EAAAvL,SAAA,eAAA,GAAA,EAAAqM,EAAApO,SACAyD,EAAA2K,EAAAT,KAAA,oBAAA,EAAAO,YAAA,EAKAE,EAAArM,SAAA,eAAA,IACAqM,EAAAC,SAAA,eAAA,EACA5K,EAAA2K,EAAAT,KAAA,oBAAA,EAAAO,YAAA,EACAE,EAAAE,YAAA,eAAA,GAGAxI,MAAArC,CAAA,GAAAA,EAAA,KACAA,EAAA,IAIA6J,EAAAvL,SAAA,WAAA,IACA0B,GAAA,IAMAA,GAAA,EAGA,CAxGAqF,EAAApL,MAAA,EAAA6Q,GAAA,OAAA,WAWAzF,EAAA,mBAAA,EAAAM,KAAA,WACA,IAAAoF,EAAA1F,EAAAnL,IAAA,EACA6P,EAAAgB,EAAAtF,KAAA,cAAA,EAEAuE,EAAAC,EADA5E,EAAAnL,IAAA,EAAAgQ,KAAA,wCAAAH,EAAA,IAAA,CACA,EACA/J,EAAAmK,EAAA,EAEAH,EAAA7P,SAAA,CACAmH,QAAAyJ,EACA1N,IAAA2C,EACAnE,WAAA,CACAmP,KAAA,CACAtP,QAAA,CAAA,CACA,CACA,CACA,CAAA,CACA,CAAA,CAzBA,CAAA,EAKA2J,EAAAxL,QAAA,EAAAiR,GAAA,oBAAAhB,CAAA,EACAzE,EAAAxL,QAAA,EAAAiR,GAAA,yBAAAhB,CAAA,CAiGA,EAAA1E,MACA","file":"../../hc-sticky.min.js","sourcesContent":["/*\n * HC-Sticky\n * =========\n * Version: 2.2.7\n * Author: Some Web Media\n * Author URL: https://github.com/somewebmedia\n * Plugin URL: https://github.com/somewebmedia/hc-sticky\n * Description: JavaScript library that makes any element on your page visible while you scroll\n * License: MIT\n */\n\n'use strict';\n\n(function(global, factory) {\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    if (global.document) {\n      module.exports = factory(global);\n    }\n    else {\n      throw new Error('HC-Sticky requires a browser to run.');\n    }\n  }\n  else if (typeof define === 'function' && define.amd) {\n    define('hcSticky', [], factory(global));\n  }\n  else {\n    factory(global);\n  }\n})(typeof window !== 'undefined' ? window : this, (window) => {\n  const document = window.document;\n\n  const DEFAULT_OPTIONS = {\n    top: 0,\n    bottom: 0,\n    bottomEnd: 0,\n    innerTop: 0,\n    innerSticker: null,\n    stickyClass: 'sticky',\n    stickTo: null,\n    followScroll: true,\n    responsive: null,\n    mobileFirst: false,\n    onStart: null,\n    onStop: null,\n    onBeforeResize: null,\n    onResize: null,\n    resizeDebounce: 100,\n    disable: false\n  };\n\n  const deprecated = (() => {\n    const pluginName = 'HC Sticky';\n\n    return (what, instead, type) => {\n      console.warn(\n        '%c' + pluginName + ':'\n        + '%c ' + type\n        + \"%c '\"+ what + \"'\"\n        + '%c is now deprecated and will be removed. Use'\n        + \"%c '\" + instead + \"'\"\n        + '%c instead.',\n        'color: #fa253b',\n        'color: default',\n        'color: #5595c6',\n        'color: default',\n        'color: #5595c6',\n        'color: default');\n    };\n  })();\n\n  const hcSticky = function(elem, userSettings) {\n    userSettings = userSettings || {};\n\n    // use querySeletor if string is passed\n    if (typeof elem === 'string') {\n      elem = document.querySelector(elem);\n    }\n\n    // check if element exist\n    if (!elem) return false;\n\n    if (userSettings.queries) {\n      deprecated('queries', 'responsive', 'option');\n    }\n\n    if (userSettings.queryFlow) {\n      deprecated('queryFlow', 'mobileFirst', 'option');\n    }\n\n    let STICKY_OPTIONS = {};\n    const Helpers = hcSticky.Helpers;\n    const elemParent = elem.parentNode;\n\n    // parent can't be static\n    if (Helpers.getStyle(elemParent, 'position') === 'static') {\n      elemParent.style.position = 'relative';\n    }\n\n    const setOptions = (options) => {\n      options = options || {};\n\n      if (Helpers.isEmptyObject(options) && !Helpers.isEmptyObject(STICKY_OPTIONS)) {\n        // nothing to set\n        return;\n      }\n\n      // extend options\n      STICKY_OPTIONS = Object.assign({}, DEFAULT_OPTIONS, STICKY_OPTIONS, options);\n    };\n\n    const resetOptions = (options) => {\n      STICKY_OPTIONS = Object.assign({}, DEFAULT_OPTIONS, options || {});\n    };\n\n    const getOptions = (option) => {\n      return option ? STICKY_OPTIONS[option] : Object.assign({}, STICKY_OPTIONS);\n    };\n\n    const isDisabled = () => {\n      return STICKY_OPTIONS.disable;\n    };\n\n    const applyQueries = () => {\n      const mediaQueries = STICKY_OPTIONS.responsive || STICKY_OPTIONS.queries;\n\n      if (mediaQueries) {\n        const window_width = window.innerWidth;\n\n        // reset settings\n        resetOptions(userSettings);\n\n        if (STICKY_OPTIONS.mobileFirst) {\n          for (const width in mediaQueries) {\n            if (window_width >= width && !Helpers.isEmptyObject(mediaQueries[width])) {\n              setOptions(mediaQueries[width]);\n            }\n          }\n        }\n        else {\n          const queriesArr = [];\n\n          // convert to array so we can reverse loop it\n          for (const b in mediaQueries) {\n            const q = {};\n\n            q[b] = mediaQueries[b];\n            queriesArr.push(q);\n          }\n\n          for (let i = queriesArr.length - 1; i >= 0; i--) {\n            const query = queriesArr[i];\n            const breakpoint = Object.keys(query)[0];\n\n            if (window_width <= breakpoint && !Helpers.isEmptyObject(query[breakpoint])) {\n              setOptions(query[breakpoint]);\n            }\n          }\n        }\n      }\n    };\n\n    // our helper function for getting necessary styles\n    const getStickyCss = (el) => {\n      const cascadedStyle = Helpers.getCascadedStyle(el);\n      const computedStyle = Helpers.getStyle(el);\n\n      const css = {\n        height: el.offsetHeight + 'px',\n        left: cascadedStyle.left,\n        right: cascadedStyle.right,\n        top: cascadedStyle.top,\n        bottom: cascadedStyle.bottom,\n        position: computedStyle.position,\n        display: computedStyle.display,\n        verticalAlign: computedStyle.verticalAlign,\n        boxSizing: computedStyle.boxSizing,\n        marginLeft: cascadedStyle.marginLeft,\n        marginRight: cascadedStyle.marginRight,\n        marginTop: cascadedStyle.marginTop,\n        marginBottom: cascadedStyle.marginBottom,\n        paddingLeft: cascadedStyle.paddingLeft,\n        paddingRight: cascadedStyle.paddingRight\n      };\n\n      if (cascadedStyle['float']) {\n        css['float'] = cascadedStyle['float'] || 'none';\n      }\n\n      if (cascadedStyle.cssFloat) {\n        css['cssFloat'] = cascadedStyle.cssFloat || 'none';\n      }\n\n      // old firefox box-sizing\n      if (computedStyle.MozBoxSizing) {\n        css['MozBoxSizing'] = computedStyle.MozBoxSizing;\n      }\n\n      css['width'] = cascadedStyle.width !== 'auto' ? cascadedStyle.width : (css.boxSizing === 'border-box' || css.MozBoxSizing === 'border-box' ? el.offsetWidth + 'px' : computedStyle.width);\n\n      return css;\n    };\n\n    const Sticky = {\n      css: {},\n      position: null, // so we don't need to check css all the time\n      stick: (args) => {\n        args = args || {};\n\n        // check if element is already sticky\n        if (Helpers.hasClass(elem, STICKY_OPTIONS.stickyClass)) {\n          return;\n        }\n\n        if (Spacer.isAttached === false) {\n          Spacer.attach();\n        }\n\n        Sticky.position = 'fixed';\n\n        // apply styles\n        elem.style.position = 'fixed';\n        elem.style.left = Spacer.offsetLeft + 'px';\n        elem.style.width = Spacer.width;\n\n        if (typeof args.bottom === 'undefined') {\n          elem.style.bottom = 'auto';\n        }\n        else {\n          elem.style.bottom = args.bottom + 'px';\n        }\n\n        if (typeof args.top === 'undefined') {\n          elem.style.top = 'auto';\n        }\n        else {\n          elem.style.top = args.top + 'px';\n        }\n\n        // add sticky class\n        if (elem.classList) {\n          elem.classList.add(STICKY_OPTIONS.stickyClass);\n        }\n        else {\n          elem.className += ' ' + STICKY_OPTIONS.stickyClass;\n        }\n\n        // fire 'start' event\n        if (STICKY_OPTIONS.onStart) {\n          STICKY_OPTIONS.onStart.call(elem, Object.assign({}, STICKY_OPTIONS));\n        }\n      },\n      release: (args) => {\n        args = args || {};\n        args.stop = args.stop || false;\n\n        // check if we've already done this\n        if (args.stop !== true && Sticky.position !== 'fixed' && Sticky.position !== null && (\n          (typeof args.top === 'undefined' && typeof args.bottom === 'undefined') ||\n          (typeof args.top !== 'undefined' && (parseInt(Helpers.getStyle(elem, 'top')) || 0) === args.top) ||\n          (typeof args.bottom !== 'undefined' && (parseInt(Helpers.getStyle(elem, 'bottom')) || 0) === args.bottom)\n        )) {\n          return;\n        }\n\n        if (args.stop === true) {\n          // remove spacer\n          if (Spacer.isAttached === true) {\n            Spacer.detach();\n          }\n        }\n        else {\n          // check spacer\n          if (Spacer.isAttached === false) {\n            Spacer.attach();\n          }\n        }\n\n        const position = args.position || Sticky.css.position;\n\n        // remember position\n        Sticky.position = position;\n\n        // apply styles\n        elem.style.position = position;\n        elem.style.left = args.stop === true ? Sticky.css.left : Spacer.positionLeft + 'px';\n        elem.style.width = position !== 'absolute' ? Sticky.css.width : Spacer.width;\n\n        if (typeof args.bottom === 'undefined') {\n          elem.style.bottom = args.stop === true ? '' : 'auto';\n        }\n        else {\n          elem.style.bottom = args.bottom + 'px';\n        }\n\n        if (typeof args.top === 'undefined') {\n          elem.style.top = args.stop === true ? '' : 'auto';\n        }\n        else {\n          elem.style.top = args.top + 'px';\n        }\n\n        // remove sticky class\n        if (elem.classList) {\n          elem.classList.remove(STICKY_OPTIONS.stickyClass);\n        }\n        else {\n          elem.className = elem.className.replace(new RegExp('(^|\\\\b)' + STICKY_OPTIONS.stickyClass.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n\n        // fire 'stop' event\n        if (STICKY_OPTIONS.onStop) {\n          STICKY_OPTIONS.onStop.call(elem, Object.assign({}, STICKY_OPTIONS));\n        }\n      }\n    };\n\n    const Spacer = {\n      el: document.createElement('div'),\n      offsetLeft: null,\n      positionLeft: null,\n      width: null,\n      isAttached: false,\n      init: () => {\n        Spacer.el.className = 'sticky-spacer';\n\n        // copy styles from sticky element\n        for (const prop in Sticky.css) {\n          Spacer.el.style[prop] = Sticky.css[prop];\n        }\n\n        // just to be sure the spacer is behind everything\n        Spacer.el.style['z-index'] = '-1';\n\n        const elemStyle = Helpers.getStyle(elem);\n\n        // get spacer offset and position\n        Spacer.offsetLeft = Helpers.offset(elem).left - (parseInt(elemStyle.marginLeft) || 0);\n        Spacer.positionLeft = Helpers.position(elem).left;\n\n        // get spacer width\n        Spacer.width = Helpers.getStyle(elem, 'width');\n      },\n      attach: () => {\n        // insert spacer to DOM\n        elemParent.insertBefore(Spacer.el, elem);\n        Spacer.isAttached = true;\n      },\n      detach: () => {\n        // remove spacer from DOM\n        Spacer.el = elemParent.removeChild(Spacer.el);\n        Spacer.isAttached = false;\n      }\n    };\n\n    // define our private variables\n    let stickTo_document;\n    let container;\n    let inner_sticker;\n\n    let container_height;\n    let container_offsetTop;\n\n    let elemParent_offsetTop;\n\n    let window_height;\n\n    let options_top;\n    let options_bottom;\n\n    let stick_top;\n    let stick_bottom;\n\n    let top_limit;\n    let bottom_limit;\n\n    let largerSticky;\n    let sticky_height;\n    let sticky_offsetTop;\n\n    let calcContainerHeight;\n    let calcStickyHeight;\n\n    const calcSticky = () => {\n      // get/set element styles\n      Sticky.css = getStickyCss(elem);\n\n      // init or reinit spacer\n      Spacer.init();\n\n      // check if referring element is document\n      stickTo_document = STICKY_OPTIONS.stickTo && (STICKY_OPTIONS.stickTo === 'document'\n        || (STICKY_OPTIONS.stickTo.nodeType && STICKY_OPTIONS.stickTo.nodeType === 9)\n        || (typeof STICKY_OPTIONS.stickTo === 'object' && STICKY_OPTIONS.stickTo instanceof (typeof HTMLDocument !== 'undefined' ? HTMLDocument : Document)))\n      ? true : false;\n\n      // select referred container\n      container = STICKY_OPTIONS.stickTo\n        ? stickTo_document\n          ? document\n          : Helpers.getElement(STICKY_OPTIONS.stickTo)\n        : elemParent;\n\n      // get sticky height\n      calcStickyHeight = () => {\n        const height = elem.offsetHeight + (parseInt(Sticky.css.marginTop) || 0) + (parseInt(Sticky.css.marginBottom) || 0);\n        const h_diff = (sticky_height || 0) - height;\n\n        if (h_diff >= -1 && h_diff <= 1) {\n          // sometimes element height changes by 1px when it get fixed position, so don't return new value\n          return sticky_height;\n        }\n        else {\n          return height;\n        }\n      };\n\n      sticky_height = calcStickyHeight();\n\n      // get container height\n      calcContainerHeight = () => {\n        return !stickTo_document ? container.offsetHeight : Math.max(document.documentElement.clientHeight, document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight);\n      };\n\n      container_height = calcContainerHeight();\n\n      container_offsetTop = !stickTo_document ? Helpers.offset(container).top : 0;\n      elemParent_offsetTop = !STICKY_OPTIONS.stickTo\n        ? container_offsetTop // parent is container\n        : !stickTo_document\n          ? Helpers.offset(elemParent).top\n          : 0;\n      window_height = window.innerHeight;\n      sticky_offsetTop = elem.offsetTop - (parseInt(Sticky.css.marginTop) || 0);\n\n      // get inner sticker element\n      inner_sticker = Helpers.getElement(STICKY_OPTIONS.innerSticker);\n\n      // top\n      options_top = isNaN(STICKY_OPTIONS.top) && STICKY_OPTIONS.top.indexOf('%') > -1\n        ? (parseFloat(STICKY_OPTIONS.top) / 100) * window_height\n        : STICKY_OPTIONS.top;\n\n      // bottom\n      options_bottom = isNaN(STICKY_OPTIONS.bottom) && STICKY_OPTIONS.bottom.indexOf('%') > -1\n        ? (parseFloat(STICKY_OPTIONS.bottom) / 100) * window_height\n        : STICKY_OPTIONS.bottom;\n\n      // calculate sticky breakpoints\n      stick_top = inner_sticker\n        ? inner_sticker.offsetTop\n        : STICKY_OPTIONS.innerTop\n          ? STICKY_OPTIONS.innerTop\n          : 0;\n\n      stick_bottom = isNaN(STICKY_OPTIONS.bottomEnd) && STICKY_OPTIONS.bottomEnd.indexOf('%') > -1\n        ? (parseFloat(STICKY_OPTIONS.bottomEnd) / 100) * window_height\n        : STICKY_OPTIONS.bottomEnd;\n\n      top_limit = container_offsetTop - options_top + stick_top + sticky_offsetTop;\n    };\n\n    // store scroll position so we can determine scroll direction\n    let last_pos = window.pageYOffset || document.documentElement.scrollTop;\n    let diff_y = 0;\n    let scroll_dir;\n\n    const runSticky = () => {\n      // always calculate sticky and container height in case of DOM change\n      sticky_height = calcStickyHeight();\n      container_height = calcContainerHeight();\n\n      bottom_limit = container_offsetTop + container_height - options_top - stick_bottom;\n\n      // check if sticky is bigger than container\n      largerSticky = sticky_height > window_height;\n\n      const offset_top = window.pageYOffset || document.documentElement.scrollTop;\n      const sticky_top = Helpers.offset(elem).top;\n      const sticky_window_top = sticky_top - offset_top;\n      let bottom_distance;\n\n      // get scroll direction\n      scroll_dir = offset_top < last_pos ? 'up' : 'down';\n      diff_y = offset_top - last_pos;\n      last_pos = offset_top;\n\n      if (offset_top > top_limit) {\n        // http://geek-and-poke.com/geekandpoke/2012/7/27/simply-explained.html\n        if (bottom_limit + options_top + (largerSticky ? options_bottom : 0) - (STICKY_OPTIONS.followScroll && largerSticky ? 0 : options_top) <= offset_top + sticky_height - stick_top - ((sticky_height - stick_top > window_height - (top_limit - stick_top) && STICKY_OPTIONS.followScroll) ? (((bottom_distance = sticky_height - window_height - stick_top) > 0) ? bottom_distance : 0) : 0)) { // bottom reached end\n          Sticky.release({\n            position: 'absolute',\n            //top: bottom_limit - sticky_height - top_limit + stick_top + sticky_offsetTop\n            bottom: elemParent_offsetTop + elemParent.offsetHeight - bottom_limit - options_top\n          });\n        }\n        else if (largerSticky && STICKY_OPTIONS.followScroll) { // sticky is bigger than container and follows scroll\n          if (scroll_dir === 'down') { // scroll down\n            if (sticky_window_top + sticky_height + options_bottom <= window_height + .9) { // stick on bottom\n              // fix subpixel precision with adding .9 pixels\n              Sticky.stick({\n                //top: window_height - sticky_height - options_bottom\n                bottom: options_bottom\n              });\n            }\n            else if (Sticky.position === 'fixed') { // bottom reached window bottom\n              Sticky.release({\n                position: 'absolute',\n                top: sticky_top - options_top - top_limit - diff_y + stick_top\n              });\n            }\n          }\n          else { // scroll up\n            if (Math.ceil(sticky_window_top + stick_top) < 0 && Sticky.position === 'fixed') { // top reached window top\n              Sticky.release({\n                position: 'absolute',\n                top: sticky_top - options_top - top_limit + stick_top - diff_y\n              });\n            }\n            else if (sticky_top >= offset_top + options_top - stick_top) { // stick on top\n              Sticky.stick({\n                top: options_top - stick_top\n              });\n            }\n          }\n        }\n        else { // stick on top\n          Sticky.stick({\n            top: options_top - stick_top\n          });\n        }\n      }\n      else { // starting point\n        Sticky.release({\n          stop: true\n        });\n      }\n    };\n\n    let scrollAttached = false;\n    let resizeAttached = false;\n\n    const disableSticky = () => {\n      if (scrollAttached) {\n        // detach sticky from scroll\n        window.removeEventListener('scroll', runSticky, Helpers.supportsPassive);\n\n        // sticky is not attached to scroll anymore\n        scrollAttached = false;\n      }\n    };\n\n    const initSticky = () => {\n      // check if element or it's parents are visible\n      if (elem.offsetParent === null || Helpers.getStyle(elem, 'display') === 'none') {\n        disableSticky();\n        return;\n      }\n\n      // calculate stuff\n      calcSticky();\n\n      // check if sticky is bigger than reffering container\n      if (sticky_height > container_height) {\n        disableSticky();\n        return;\n      }\n\n      // run\n      runSticky();\n\n      if (!scrollAttached) {\n        // attach sticky to scroll\n        window.addEventListener('scroll', runSticky, Helpers.supportsPassive);\n\n        // sticky is attached to scroll\n        scrollAttached = true;\n      }\n    };\n\n    const resetSticky = () => {\n      // remove inline styles\n      elem.style.position = '';\n      elem.style.left = '';\n      elem.style.top = '';\n      elem.style.bottom = '';\n      elem.style.width = '';\n\n      // remove sticky class\n      if (elem.classList) {\n        elem.classList.remove(STICKY_OPTIONS.stickyClass);\n      }\n      else {\n        elem.className = elem.className.replace(new RegExp('(^|\\\\b)' + STICKY_OPTIONS.stickyClass.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n\n      // reset sticky object data\n      Sticky.css = {};\n      Sticky.position = null;\n\n      // remove spacer\n      if (Spacer.isAttached === true) {\n        Spacer.detach();\n      }\n    };\n\n    const reinitSticky = () => {\n      resetSticky();\n      applyQueries();\n\n      if (isDisabled()) {\n        disableSticky();\n        return;\n      }\n\n      // restart sticky\n      initSticky();\n    };\n\n    const resizeSticky = () => {\n      // fire 'beforeResize' event\n      if (STICKY_OPTIONS.onBeforeResize) {\n        STICKY_OPTIONS.onBeforeResize.call(elem, Object.assign({}, STICKY_OPTIONS));\n      }\n\n      // reinit sticky\n      reinitSticky();\n\n      // fire 'resize' event\n      if (STICKY_OPTIONS.onResize) {\n        STICKY_OPTIONS.onResize.call(elem, Object.assign({}, STICKY_OPTIONS));\n      }\n    };\n\n    const resize_cb = !STICKY_OPTIONS.resizeDebounce ? resizeSticky : Helpers.debounce(resizeSticky, STICKY_OPTIONS.resizeDebounce);\n\n    // Method for updating options\n    const Update = (options) => {\n      setOptions(options);\n\n      // also update user settings\n      userSettings = Object.assign({}, userSettings, options || {});\n\n      reinitSticky();\n    };\n\n    const Detach = () => {\n      // detach resize reinit\n      if (resizeAttached) {\n        window.removeEventListener('resize', resize_cb, Helpers.supportsPassive);\n        resizeAttached = false;\n      }\n\n      disableSticky();\n    };\n\n    const Destroy = () => {\n      Detach();\n      resetSticky();\n    };\n\n    const Attach = () => {\n      // attach resize reinit\n      if (!resizeAttached) {\n        window.addEventListener('resize', resize_cb, Helpers.supportsPassive);\n        resizeAttached = true;\n      }\n\n      applyQueries();\n\n      if (isDisabled()) {\n        disableSticky();\n        return;\n      }\n\n      initSticky();\n    };\n\n    this.options = getOptions;\n    this.refresh = reinitSticky;\n    this.update = Update;\n    this.attach = Attach;\n    this.detach = Detach;\n    this.destroy = Destroy;\n\n    // jQuery methods\n    this.triggerMethod = (method, options) => {\n      if (typeof this[method] === 'function') {\n        this[method](options);\n      }\n    };\n\n    this.reinit = () => {\n      deprecated('reinit', 'refresh', 'method');\n      reinitSticky();\n    };\n\n    // init settings\n    setOptions(userSettings);\n\n    // start sticky\n    Attach();\n\n    // reinit on complete page load\n    window.addEventListener('load', reinitSticky);\n  };\n\n  // jQuery Plugin\n  if (typeof window.jQuery !== 'undefined') {\n    const $ = window.jQuery;\n    const namespace = 'hcSticky';\n\n    $.fn.extend({\n      hcSticky: function(args, update) {\n        // check if selected element exist\n        if (!this.length) return this;\n\n        // we need to return options\n        if (args === 'options') {\n          return $.data(this.get(0), namespace).options();\n        }\n\n        return this.each(function() {\n          let instance = $.data(this, namespace);\n\n          if (instance) {\n            // already created, trigger method\n            instance.triggerMethod(args, update);\n          }\n          else {\n            // create new instance\n            instance = new hcSticky(this, args);\n            $.data(this, namespace, instance);\n          }\n        });\n      }\n    });\n  }\n\n  // browser global\n  window.hcSticky = window.hcSticky || hcSticky;\n\n  return hcSticky;\n});\n","((window) => {\n  'use strict';\n\n  const hcSticky = window.hcSticky;\n  const document = window.document;\n\n  /*\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n   */\n  if (typeof Object.assign !== 'function') {\n    Object.defineProperty(Object, 'assign', {\n      value: function assign(target, varArgs) {\n        'use strict';\n        if (target == null) {\n          throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var to = Object(target);\n\n        for (var index = 1; index < arguments.length; index++) {\n          var nextSource = arguments[index];\n\n          if (nextSource != null) {\n            for (var nextKey in nextSource) {\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n        return to;\n      },\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /*\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n   */\n  if (!Array.prototype.forEach) {\n    Array.prototype.forEach = function(callback) {\n      var T, k;\n\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n\n      var O = Object(this);\n      var len = O.length >>> 0;\n\n      if (typeof callback !== 'function') {\n        throw new TypeError(callback + ' is not a function');\n      }\n\n      if (arguments.length > 1) {\n        T = arguments[1];\n      }\n\n      k = 0;\n\n      while (k < len) {\n        var kValue;\n\n        if (k in O) {\n          kValue = O[k];\n          callback.call(T, kValue, k, O);\n        }\n\n        k++;\n      }\n    };\n  }\n\n  let supportsPassive = false;\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get: function() {\n        supportsPassive = {passive: false};\n      }\n    });\n    window.addEventListener('testPassive', null, opts);\n    window.removeEventListener('testPassive', null, opts);\n  } catch (e) {}\n\n  const getElement = (el) => {\n    let node = null;\n\n    if (typeof el === 'string') {\n      node = document.querySelector(el);\n    }\n    else if (window.jQuery && el instanceof window.jQuery && el.length) {\n      node = el[0];\n    }\n    else if (el instanceof Element) {\n      node = el;\n    }\n\n    return node;\n  };\n\n  // debounce taken from underscore\n  const debounce = (func, wait, immediate) => {\n    let timeout;\n\n    return function() {\n      const context = this;\n      const args = arguments;\n      const later = function() {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      };\n      const callNow = immediate && !timeout;\n\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n\n      if (callNow) {\n        func.apply(context, args);\n      }\n    };\n  };\n\n  // cross-browser get style\n  const getStyle = (el, style) => {\n    if (window.getComputedStyle) {\n      return style ? document.defaultView.getComputedStyle(el, null).getPropertyValue(style) : document.defaultView.getComputedStyle(el, null);\n    }\n    else if (el.currentStyle) {\n      return style ? el.currentStyle[style.replace(/-\\w/g, (s) => {\n        return s.toUpperCase().replace('-', '');\n      })] : el.currentStyle;\n    }\n  };\n\n  // check if object is empty\n  const isEmptyObject = (obj) => {\n    for (const name in obj) {\n      return false;\n    }\n\n    return true;\n  };\n\n  // check if element has class\n  const hasClass = (el, className) => {\n    if (el.classList) {\n      return el.classList.contains(className);\n    }\n    else {\n      return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);\n    }\n  };\n\n  // like jQuery .offset()\n  const offset = (el) => {\n    const rect = el.getBoundingClientRect();\n    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;\n\n    return {\n      top: rect.top + scrollTop,\n      left: rect.left + scrollLeft\n    };\n  };\n\n  // like jQuery .position()\n  const position = (el) => {\n    const offsetParent = el.offsetParent;\n    const parentOffset = offset(offsetParent);\n    const elemOffset = offset(el);\n    const prentStyle = getStyle(offsetParent);\n    const elemStyle = getStyle(el);\n\n    parentOffset.top += parseInt(prentStyle.borderTopWidth) || 0;\n    parentOffset.left += parseInt(prentStyle.borderLeftWidth) || 0;\n\n    return {\n      top: elemOffset.top - parentOffset.top - (parseInt(elemStyle.marginTop) || 0),\n      left: elemOffset.left - parentOffset.left - (parseInt(elemStyle.marginLeft) || 0)\n    };\n  };\n\n  // get cascaded instead of computed styles\n  const getCascadedStyle = (el) => {\n    // clone element\n    let clone = el.cloneNode(true);\n\n    clone.style.display = 'none';\n\n    // remove name attr from cloned radio buttons to prevent their clearing\n    Array.prototype.slice.call(clone.querySelectorAll('input[type=\"radio\"]')).forEach((el) => {\n      el.removeAttribute('name');\n    });\n\n    // insert clone to DOM\n    el.parentNode.insertBefore(clone, el.nextSibling);\n\n    // get styles\n    let currentStyle;\n\n    if (clone.currentStyle) {\n      currentStyle = clone.currentStyle;\n    }\n    else if (window.getComputedStyle) {\n      currentStyle = document.defaultView.getComputedStyle(clone, null);\n    }\n\n    // new style oject\n    let style = {};\n\n    for (const prop in currentStyle) {\n      if (isNaN(prop) && (typeof currentStyle[prop] === 'string' || typeof currentStyle[prop] === 'number')) {\n        style[prop] = currentStyle[prop];\n      }\n    }\n\n    // safari copy\n    if (Object.keys(style).length < 3) {\n      style = {}; // clear\n      for (const prop in currentStyle) {\n        if (!isNaN(prop)) {\n          style[currentStyle[prop].replace(/-\\w/g, (s) => {\n            return s.toUpperCase().replace('-', '');\n          })] = currentStyle.getPropertyValue(currentStyle[prop]);\n        }\n      }\n    }\n\n    // check for margin:auto\n    if (!style.margin && style.marginLeft === 'auto') {\n      style.margin = 'auto';\n    }\n    else if (!style.margin && style.marginLeft === style.marginRight && style.marginLeft === style.marginTop && style.marginLeft === style.marginBottom) {\n      style.margin = style.marginLeft;\n    }\n\n    // safari margin:auto hack\n    if (!style.margin && style.marginLeft === '0px' && style.marginRight === '0px') {\n      const posLeft = el.offsetLeft - el.parentNode.offsetLeft;\n      const marginLeft = posLeft - (parseInt(style.left) || 0) - (parseInt(style.right) || 0);\n      const marginRight = el.parentNode.offsetWidth - el.offsetWidth - posLeft - (parseInt(style.right) || 0) + (parseInt(style.left) || 0);\n      const diff = marginRight - marginLeft;\n\n      if (diff === 0 || diff === 1) {\n        style.margin = 'auto';\n      }\n    }\n\n    // destroy clone\n    clone.parentNode.removeChild(clone);\n    clone = null;\n\n    return style;\n  };\n\n  hcSticky.Helpers = {\n    supportsPassive,\n    isEmptyObject,\n    debounce,\n    hasClass,\n    offset,\n    position,\n    getElement,\n    getStyle,\n    getCascadedStyle\n  };\n\n})(window);\n","(\n\tfunction( $ ) {\n\t\t'use strict';\n\n\t\tvar $body = $( 'body' );\n\n\t\t/**\n\t\t * Waiting for header sticky init.\n\t\t */\n\t\t$( window ).on( 'load', function() {\n\t\t\tinitStickyElement();\n\t\t} );\n\n\t\t/**\n\t\t * Re init sticky kit when some components heights changed.\n\t\t */\n\t\t$( document ).on( 'MinimogTabsChange', updateStickySize );\n\t\t$( document ).on( 'MinimogAccordionChange', updateStickySize );\n\n\t\tfunction initStickyElement() {\n\t\t\t$( '.tm-sticky-parent' ).each( function() {\n\t\t\t\tvar $parent = $( this );\n\t\t\t\tvar group = $parent.data( 'sticky-group' );\n\t\t\t\tvar $columns = $( this ).find( '.tm-sticky-column[data-sticky-group=\"' + group + '\"]' );\n\t\t\t\tvar $stickyColumns = getStickyColumns( $columns );\n\t\t\t\tvar offset = getStickyOffset();\n\n\t\t\t\t$stickyColumns.hcSticky( {\n\t\t\t\t\tstickTo: $parent,\n\t\t\t\t\ttop: offset,\n\t\t\t\t\tresponsive: {\n\t\t\t\t\t\t1007: { // 992px. Append scrollbar width.\n\t\t\t\t\t\t\tdisable: true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\n\t\tfunction updateStickyOffset() {\n\t\t\t$( '.tm-sticky-parent' ).each( function() {\n\t\t\t\tvar $parent = $( this );\n\t\t\t\tvar group = $parent.data( 'sticky-group' );\n\t\t\t\tvar $columns = $( this ).find( '.tm-sticky-column[data-sticky-group=\"' + group + '\"]' );\n\t\t\t\tvar $stickyColumns = getStickyColumns( $columns );\n\t\t\t\tvar offset = getStickyOffset();\n\n\t\t\t\t$stickyColumns.hcSticky( 'update', {\n\t\t\t\t\ttop: offset\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\n\t\tfunction updateStickySize() {\n\t\t\t$( '.tm-sticky-parent' ).each( function() {\n\t\t\t\tvar $parent = $( this );\n\t\t\t\tvar group = $parent.data( 'sticky-group' );\n\t\t\t\tvar $columns = $( this ).find( '.tm-sticky-column[data-sticky-group=\"' + group + '\"]' );\n\t\t\t\tvar $stickyColumns = getStickyColumns( $columns );\n\t\t\t\tvar offset = getStickyOffset();\n\n\t\t\t\t$stickyColumns.hcSticky( 'refresh' );\n\n\t\t\t\t$( window ).trigger( 'scroll' );\n\t\t\t} );\n\t\t}\n\n\t\tfunction getStickyColumns( $columns ) {\n\t\t\tvar $highestColumn;\n\t\t\tvar highestHeight = 0;\n\n\t\t\t$columns.each( function() {\n\t\t\t\tvar thisArea = $( this ).outerHeight();\n\t\t\t\tif ( thisArea > highestHeight ) {\n\t\t\t\t\t$highestColumn = $( this );\n\t\t\t\t\thighestHeight = thisArea;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn $columns.not( $highestColumn );\n\t\t}\n\n\t\tfunction getStickyOffset() {\n\t\t\tvar $pageHeader = $( '#page-header' );\n\t\t\tvar offset = 0;\n\n\t\t\tif ( $body.hasClass( 'header-pinned' ) && $pageHeader.length > 0 ) {\n\t\t\t\toffset = $pageHeader.find( '#page-header-inner' ).outerHeight();\n\n\t\t\t\t/**\n\t\t\t\t * Header sticky smaller than normal header.\n\t\t\t\t */\n\t\t\t\tif ( ! $pageHeader.hasClass( 'header-pinned' ) ) {\n\t\t\t\t\t$pageHeader.addClass( 'header-pinned' );\n\t\t\t\t\toffset = $pageHeader.find( '#page-header-inner' ).outerHeight();\n\t\t\t\t\t$pageHeader.removeClass( 'header-pinned' );\n\t\t\t\t}\n\n\t\t\t\tif ( isNaN( offset ) || offset < 0 ) {\n\t\t\t\t\toffset = 70;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $body.hasClass( 'admin-bar' ) ) {\n\t\t\t\toffset += 32;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Spacing header with content.\n\t\t\t */\n\t\t\toffset += 30;\n\n\t\t\treturn offset;\n\t\t}\n\t}( jQuery )\n);\n"]}